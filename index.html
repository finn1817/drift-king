<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DRIFT KING - Enhanced Drift & Daytona Race Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0e1f3a 0%, #1e3c72 45%, #2a5298 100%);
            color: white;
            overflow: hidden;
        }

        #gameContainer {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            border: 3px solid #fff;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.65);
            border-radius: 12px;
        }

        #hud {
            position: absolute;
            top: 16px;
            left: 16px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
            z-index: 10;
        }

        #hud div {
            min-width: 220px;
            background: rgba(0, 0, 0, 0.65);
            padding: 10px 16px;
            border-radius: 10px;
            font-size: 17px;
            line-height: 1.4;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.35);
        }

        .label {
            color: #ffd700;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.72);
            padding: 18px 20px;
            border-radius: 12px;
            max-width: 320px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.35);
        }

        #controls h3 {
            margin-bottom: 12px;
            color: #ffd700;
        }

        #controls p {
            margin: 4px 0;
            line-height: 1.5;
        }

        .hidden {
            display: none !important;
        }

        @media (max-width: 900px) {
            canvas {
                width: 95vw !important;
                height: auto !important;
            }

            #controls {
                max-width: 260px;
                font-size: 13px;
                padding: 14px 16px;
            }

            #hud div {
                font-size: 15px;
                min-width: 180px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer"></div>

    <div id="hud">
        <div id="speedContainer"><span class="label">Speed:</span> <span id="speedDisplay">0</span> MPH</div>
        <div id="carContainer"><span class="label">Car:</span> <span id="carType">--</span></div>
        <div id="trackContainer"><span class="label">Track:</span> <span id="trackName">Select a Track</span></div>
        <div id="weatherContainer"><span class="label">Weather:</span> <span id="weather">Clear ‚òÄÔ∏è</span></div>
        <div id="healthContainer" class="hidden"><span class="label">Health:</span> <span id="healthDisplay">--</span></div>
        <div id="lapContainer" class="hidden"><span class="label">Lap:</span> <span id="lapDisplay">--</span></div>
        <div id="positionContainer" class="hidden"><span class="label">Position:</span> <span id="positionDisplay">--</span></div>
    </div>

    <div id="controls">
        <h3>üéÆ CONTROLS</h3>
        <p><strong>W / ‚Üë:</strong> Throttle</p>
        <p><strong>S / ‚Üì:</strong> Brake / Reverse</p>
        <p><strong>A / ‚Üê and D / ‚Üí:</strong> Steering</p>
        <p><strong>SPACE:</strong> Handbrake (drift assist)</p>
        <p><strong>R:</strong> Reset Car</p>
        <p><strong>T:</strong> Toggle Rain</p>
        <p><strong>ESC:</strong> Back to Menu</p>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <script>
        const PIXELS_PER_MPH = 1080 / 65;
        const mphToPixels = mph => mph * PIXELS_PER_MPH;
        const DEG2RAD = Math.PI / 180;

        // Helper: Move a value towards a target by at most maxDelta (no overshoot)
        const moveTowards = (current, target, maxDelta) => {
            if (current < target) return Math.min(current + maxDelta, target);
            if (current > target) return Math.max(current - maxDelta, target);
            return target;
        };

        const CAR_TYPES = {
            drift: {
                id: 'drift',
                name: 'Drift King',
                description: 'Rear-biased setup built to hold long slides.',
                topSpeedMph: 66,
                topSpeed: mphToPixels(66),
                engineForce: mphToPixels(34),
                brakeForce: mphToPixels(62),
                handbrakeForce: mphToPixels(88),
                maxReverseSpeed: mphToPixels(28),
                mass: 1180,
                inertia: 2600,
                cgToFront: 88,
                cgToRear: 102,
                cornerStiffnessFront: 7200,
                cornerStiffnessRear: 5200,
                maxLateralForce: 13000,
                maxSteerAngle: 35,
                steerRate: 6.4,
                lateralDamping: 4.0,
                angularDamping: 2.9,
                longitudinalDrag: 0.26,
                rollingResistance: 7.6,
                paint: {
                    base: 0xc83434,
                    secondary: 0x101010,
                    accent: 0xffffff,
                    decal: 'katana'
                }
            },
            balanced: {
                id: 'balanced',
                name: 'Apex GT',
                description: 'Stable all-rounder tuned for consistency.',
                topSpeedMph: 69,
                topSpeed: mphToPixels(69),
                engineForce: mphToPixels(36),
                brakeForce: mphToPixels(68),
                handbrakeForce: mphToPixels(80),
                maxReverseSpeed: mphToPixels(26),
                mass: 1240,
                inertia: 2850,
                cgToFront: 92,
                cgToRear: 96,
                cornerStiffnessFront: 8200,
                cornerStiffnessRear: 7600,
                maxLateralForce: 14200,
                maxSteerAngle: 32,
                steerRate: 6.1,
                lateralDamping: 4.6,
                angularDamping: 3.1,
                longitudinalDrag: 0.24,
                rollingResistance: 7.2,
                paint: {
                    base: 0x2874ff,
                    secondary: 0x0f1b33,
                    accent: 0xf7f9ff,
                    decal: 'dualStripe'
                }
            },
            speedster: {
                id: 'speedster',
                name: 'Velocity RS',
                description: 'Higher top-end and lighter weight for sprints.',
                topSpeedMph: 73,
                topSpeed: mphToPixels(73),
                engineForce: mphToPixels(33),
                brakeForce: mphToPixels(54),
                handbrakeForce: mphToPixels(92),
                maxReverseSpeed: mphToPixels(25),
                mass: 1160,
                inertia: 2450,
                cgToFront: 94,
                cgToRear: 90,
                cornerStiffnessFront: 7600,
                cornerStiffnessRear: 6200,
                maxLateralForce: 12600,
                maxSteerAngle: 31,
                steerRate: 6.8,
                lateralDamping: 3.7,
                angularDamping: 2.6,
                longitudinalDrag: 0.28,
                rollingResistance: 6.4,
                paint: {
                    base: 0xff8b1f,
                    secondary: 0x1b120c,
                    accent: 0xfef2d5,
                    decal: 'speedChevron'
                }
            },
            endurance: {
                id: 'endurance',
                name: 'Bulldog SX',
                description: 'Durable bruiser with dependable grip.',
                topSpeedMph: 62,
                topSpeed: mphToPixels(62),
                engineForce: mphToPixels(35),
                brakeForce: mphToPixels(72),
                handbrakeForce: mphToPixels(70),
                maxReverseSpeed: mphToPixels(24),
                mass: 1320,
                inertia: 3120,
                cgToFront: 86,
                cgToRear: 110,
                cornerStiffnessFront: 8800,
                cornerStiffnessRear: 8200,
                maxLateralForce: 15000,
                maxSteerAngle: 30,
                steerRate: 5.6,
                lateralDamping: 5.2,
                angularDamping: 3.4,
                longitudinalDrag: 0.22,
                rollingResistance: 8.2,
                paint: {
                    base: 0x4ad05f,
                    secondary: 0x17311d,
                    accent: 0xdfffdc,
                    decal: 'enduranceNumber',
                    number: 42
                }
            }
        };

        const DAYTONA_CONFIG = (() => {
            const worldWidth = 6200;
            const worldHeight = 3800;
            const centerX = worldWidth / 2;
            const centerY = worldHeight / 2;
            const outerRadiusX = 2300;
            const outerRadiusY = 1300;
            const innerRadiusX = 1700;
            const innerRadiusY = 850;
            const midRadiusX = (outerRadiusX + innerRadiusX) / 2;
            const midRadiusY = (outerRadiusY + innerRadiusY) / 2;
            const segments = 64;
            const baseAngle = Math.PI / 2;
            const waypoints = [];
            for (let i = 0; i < segments; i++) {
                const t = baseAngle + (i / segments) * Math.PI * 2;
                const x = centerX + Math.cos(t) * midRadiusX;
                const y = centerY + Math.sin(t) * midRadiusY;
                waypoints.push({ x, y });
            }
            const laneSpacing = 120;
            const startY = centerY + midRadiusY - 60;
            const startPositions = [
                { x: centerX - laneSpacing * 0.5, y: startY, angle: -Math.PI / 2 },
                { x: centerX + laneSpacing * 0.5, y: startY, angle: -Math.PI / 2 }
            ];
            return {
                worldWidth,
                worldHeight,
                centerX,
                centerY,
                outerRadiusX,
                outerRadiusY,
                innerRadiusX,
                innerRadiusY,
                midRadiusX,
                midRadiusY,
                trackWidth: outerRadiusX - innerRadiusX,
                waypoints,
                startPositions
            };
        })();

        const TRACKS = {
            lot: {
                id: 'lot',
                name: 'The Lot',
                description: 'A wide-open parking lot tuned for drifting practice.',
                type: 'drift',
                worldWidth: 5200,
                worldHeight: 5200,
                cameraZoom: 0.8,
                startPositions: [{ x: 2600, y: 2600, angle: -Math.PI / 2 }],
                allowRain: true
            },
            daytona: {
                id: 'daytona',
                name: 'Sunset Speedway (Daytona Style)',
                description: 'High-speed oval with gentle banking. Includes AI rival.',
                type: 'race',
                worldWidth: DAYTONA_CONFIG.worldWidth,
                worldHeight: DAYTONA_CONFIG.worldHeight,
                cameraZoom: 0.63,
                allowRain: true,
                startPositions: DAYTONA_CONFIG.startPositions,
                outerRadiusX: DAYTONA_CONFIG.outerRadiusX,
                outerRadiusY: DAYTONA_CONFIG.outerRadiusY,
                innerRadiusX: DAYTONA_CONFIG.innerRadiusX,
                innerRadiusY: DAYTONA_CONFIG.innerRadiusY,
                midRadiusX: DAYTONA_CONFIG.midRadiusX,
                midRadiusY: DAYTONA_CONFIG.midRadiusY,
                centerX: DAYTONA_CONFIG.centerX,
                centerY: DAYTONA_CONFIG.centerY,
                trackWidth: DAYTONA_CONFIG.trackWidth,
                race: {
                    laps: 3,
                    waypointRadius: 240,
                    waypoints: DAYTONA_CONFIG.waypoints,
                    aiCount: 1
                }
            }
        };

        class MenuScene extends Phaser.Scene {
            constructor() {
                super({ key: 'MenuScene' });
            }

            init() {
                this.selectedCarId = 'drift';
                this.trackButtons = [];
                this.carCards = [];
            }

            create() {
                this.add.rectangle(640, 360, 1280, 720, 0x000000, 0.25);

                this.add.text(640, 110, 'DRIFT KING', {
                    fontFamily: 'Arial Black',
                    fontSize: '78px',
                    fill: '#ffd700',
                    stroke: '#000',
                    strokeThickness: 8
                }).setOrigin(0.5);

                this.add.text(640, 170, 'Drift Playground & Daytona-Style Oval Duel', {
                    fontFamily: 'Arial',
                    fontSize: '24px',
                    fill: '#ffffff'
                }).setOrigin(0.5);

                this.createCarSelector();
                this.createTrackSelector();

                this.add.text(640, 650, 'Tip: Pick a car, then choose your track. Daytona launches a race vs AI!', {
                    fontFamily: 'Arial',
                    fontSize: '20px',
                    fill: '#cccccc'
                }).setOrigin(0.5);

                document.getElementById('carType').textContent = '--';
                document.getElementById('trackName').textContent = 'Select a Track';
                document.getElementById('speedDisplay').textContent = '0';
                document.getElementById('weather').textContent = 'Clear ‚òÄÔ∏è';
                document.getElementById('healthContainer').classList.add('hidden');
                document.getElementById('lapContainer').classList.add('hidden');
                document.getElementById('positionContainer').classList.add('hidden');
            }

            createCarSelector() {
                this.add.text(360, 235, 'SELECT YOUR CAR', {
                    fontFamily: 'Arial Black',
                    fontSize: '30px',
                    fill: '#ffd700'
                }).setOrigin(0.5);

                const carEntries = Object.values(CAR_TYPES);
                carEntries.forEach((car, index) => {
                    const baseY = 295 + index * 95;
                    const container = this.add.container(240, baseY);
                    const bg = this.add.rectangle(0, 0, 420, 82, 0x0c1424, 0.68).setStrokeStyle(2, 0x89c4ff, 0.35);
                    const title = this.add.text(-190, -24, car.name, {
                        fontFamily: 'Arial',
                        fontSize: '24px',
                        fill: '#ffffff'
                    });
                    const desc = this.add.text(-190, 6, car.description, {
                        fontFamily: 'Arial',
                        fontSize: '16px',
                        fill: '#a8d8ff'
                    });

                    const stats = this.add.text(-190, 36, `Top ${car.topSpeedMph} mph ‚Ä¢ Grip ${(car.cornerStiffnessRear / 100).toFixed(0)}%`, {
                        fontFamily: 'Arial',
                        fontSize: '16px',
                        fill: '#ffd700'
                    });

                    container.add([bg, title, desc, stats]);
                    container.setSize(420, 82);
                    container.setInteractive(new Phaser.Geom.Rectangle(-210, -41, 420, 82), Phaser.Geom.Rectangle.Contains);
                    container.on('pointerover', () => bg.setFillStyle(0x132444, 0.85));
                    container.on('pointerout', () => {
                        if (this.selectedCarId !== car.id) {
                            bg.setFillStyle(0x0c1424, 0.68);
                        }
                    });
                    container.on('pointerdown', () => this.selectCar(car.id));

                    this.carCards.push({ container, bg, car });
                });

                this.selectCar(this.selectedCarId);
            }

            selectCar(carId) {
                this.selectedCarId = carId;
                this.carCards.forEach(({ bg, car }) => {
                    if (car.id === carId) {
                        bg.setFillStyle(0x20406a, 0.9);
                        bg.setStrokeStyle(3, 0xffd700, 0.8);
                    } else {
                        bg.setFillStyle(0x0c1424, 0.68);
                        bg.setStrokeStyle(2, 0x89c4ff, 0.35);
                    }
                });
            }

            createTrackSelector() {
                this.add.text(930, 235, 'CHOOSE YOUR TRACK', {
                    fontFamily: 'Arial Black',
                    fontSize: '30px',
                    fill: '#ffd700'
                }).setOrigin(0.5);

                const trackEntries = Object.values(TRACKS);
                trackEntries.forEach((track, index) => {
                    const baseY = 305 + index * 150;
                    const container = this.add.container(820, baseY);
                    const bg = this.add.rectangle(0, 0, 420, 120, 0x211028, 0.7)
                        .setStrokeStyle(3, track.type === 'race' ? 0xff6f61 : 0x6fff61, 0.6);

                    const title = this.add.text(-190, -38, track.name, {
                        fontFamily: 'Arial',
                        fontSize: '26px',
                        fill: '#ffffff'
                    });

                    const desc = this.add.text(-190, -6, track.description, {
                        fontFamily: 'Arial',
                        fontSize: '16px',
                        fill: '#dadada',
                        wordWrap: { width: 360 }
                    });

                    const modeText = track.type === 'race'
                        ? 'Mode: Race vs AI ‚Ä¢ 3 Laps'
                        : 'Mode: Freeroam Drift';

                    const meta = this.add.text(-190, 40, modeText, {
                        fontFamily: 'Arial',
                        fontSize: '16px',
                        fill: track.type === 'race' ? '#ffab91' : '#aaff91'
                    });

                    container.add([bg, title, desc, meta]);
                    container.setSize(420, 120);
                    container.setInteractive(new Phaser.Geom.Rectangle(-210, -60, 420, 120), Phaser.Geom.Rectangle.Contains);

                    container.on('pointerover', () => bg.setFillStyle(0x351a3d, 0.85));
                    container.on('pointerout', () => bg.setFillStyle(0x211028, 0.7));
                    container.on('pointerdown', () => this.launchTrack(track.id));

                    this.trackButtons.push({ container, bg, track });
                });
            }

            launchTrack(trackId) {
                this.scene.start('GameScene', {
                    track: trackId,
                    car: this.selectedCarId
                });
            }
        }

        class GameScene extends Phaser.Scene {
            constructor() {
                super({ key: 'GameScene' });
            }

            init(data) {
                this.trackId = data.track || 'lot';
                this.carId = data.car || 'drift';
                this.trackConfig = TRACKS[this.trackId] || TRACKS.lot;
                this.carData = CAR_TYPES[this.carId] || CAR_TYPES.drift;

                this.worldWidth = this.trackConfig.worldWidth;
                this.worldHeight = this.trackConfig.worldHeight;

                this.playerCar = null;
                this.aiCars = [];
                this.cars = [];
                this.racers = [];
                this.finishOrder = [];
                this.isRaceTrack = this.trackConfig.type === 'race';
                this.raceState = this.isRaceTrack ? 'grid' : 'free';
                this.surfaceGrip = 1;
                this.isRaining = false;
                this.lastWallHitTime = 0;

                this.hud = {
                    speed: document.getElementById('speedDisplay'),
                    carName: document.getElementById('carType'),
                    trackName: document.getElementById('trackName'),
                    weather: document.getElementById('weather'),
                    healthContainer: document.getElementById('healthContainer'),
                    health: document.getElementById('healthDisplay'),
                    lapContainer: document.getElementById('lapContainer'),
                    lap: document.getElementById('lapDisplay'),
                    positionContainer: document.getElementById('positionContainer'),
                    position: document.getElementById('positionDisplay')
                };
            }

            create() {
                this.createTextures();
                this.createWorld();
                this.createCars();
                this.setupCamera();
                this.setupControls();
                this.setupCollisions();
                this.createUIOverlays();

                this.updateHUD(true);

                if (this.isRaceTrack) {
                    this.startRaceCountdown();
                }
            }

            createTextures() {
                Object.values(CAR_TYPES).forEach(car => {
                    const key = `car_${car.id}`;
                    if (!this.textures.exists(key)) {
                        this.drawCarTexture(car, key);
                    }
                });

                if (!this.textures.exists('wallTexture')) {
                    const gw = this.add.graphics();
                    gw.fillStyle(0xffffff, 1);
                    gw.fillRect(0, 0, 120, 36);
                    gw.generateTexture('wallTexture', 120, 36);
                    gw.destroy();
                }
            }

            drawCarTexture(car, key) {
                const width = 160;
                const height = 72;
                const g = this.add.graphics();
                const paint = car.paint;

                g.fillStyle(0x0d0d0d, 1);
                g.fillRoundedRect(0, 0, width, height, 22);

                g.fillStyle(paint.base, 1);
                g.fillRoundedRect(6, 8, width - 12, height - 16, 18);

                g.fillStyle(paint.secondary, 1);
                g.fillRoundedRect(20, 14, width - 40, height - 28, 14);

                if (paint.decal === 'dualStripe') {
                    g.fillStyle(paint.accent, 0.95);
                    g.fillRoundedRect(width * 0.36, 8, 14, height - 16, 12);
                    g.fillRoundedRect(width * 0.50, 8, 14, height - 16, 12);
                } else if (paint.decal === 'katana') {
                    g.fillStyle(paint.accent, 0.85);
                    g.beginPath();
                    g.moveTo(30, height - 18);
                    g.lineTo(width - 18, 18);
                    g.lineTo(width - 26, 12);
                    g.lineTo(22, height - 24);
                    g.closePath();
                    g.fillPath();
                } else if (paint.decal === 'speedChevron') {
                    g.fillStyle(paint.accent, 0.85);
                    g.beginPath();
                    g.moveTo(width * 0.35, 12);
                    g.lineTo(width * 0.82, height / 2);
                    g.lineTo(width * 0.35, height - 12);
                    g.closePath();
                    g.fillPath();
                } else if (paint.decal === 'enduranceNumber') {
                    g.fillStyle(0x112611, 0.95);
                    g.fillRoundedRect(30, 16, width - 60, height - 32, 12);
                    g.fillStyle(paint.accent, 1);
                    this.add.text(0, 0, paint.number || 99, {
                        fontFamily: 'Arial Black',
                        fontSize: '24px',
                        color: '#0b170b'
                    }).setPosition(width / 2 - 12, height / 2 - 14).setDepth(0.01);
                }

                g.fillStyle(0xffffff, 0.92);
                g.fillRoundedRect(width - 34, height / 2 - 12, 20, 24, 6);

                g.lineStyle(4, 0xffffff, 0.35);
                g.strokeRoundedRect(6, 8, width - 12, height - 16, 18);

                g.generateTexture(key, width, height);
                g.destroy();
            }

            createWorld() {
                this.physics.world.setBounds(0, 0, this.worldWidth, this.worldHeight);
                this.trackWalls = this.physics.add.staticGroup();

                if (this.trackId === 'lot') {
                    this.createLotWorld();
                } else if (this.trackId === 'daytona') {
                    this.createDaytonaWorld();
                }
            }

            createLotWorld() {
                this.add.rectangle(this.worldWidth / 2, this.worldHeight / 2, this.worldWidth, this.worldHeight, 0x303030).setDepth(-10);

                const graphics = this.add.graphics({ depth: -8 });
                graphics.lineStyle(2, 0xffff99, 0.28);

                for (let x = 200; x < this.worldWidth; x += 160) {
                    graphics.lineBetween(x, 140, x, this.worldHeight - 140);
                }
                for (let y = 200; y < this.worldHeight; y += 120) {
                    graphics.lineBetween(140, y, this.worldWidth - 140, y);
                }

                const boundaryGraphics = this.add.graphics({ depth: -9 });
                boundaryGraphics.lineStyle(16, 0x1f1f1f, 0.9);
                boundaryGraphics.strokeRect(60, 60, this.worldWidth - 120, this.worldHeight - 120);
            }

            createDaytonaWorld() {
                const {
                    centerX,
                    centerY,
                    outerRadiusX,
                    outerRadiusY,
                    innerRadiusX,
                    innerRadiusY
                } = this.trackConfig;

                this.add.rectangle(this.worldWidth / 2, this.worldHeight / 2, this.worldWidth, this.worldHeight, 0x173018).setDepth(-12);

                const g = this.add.graphics({ depth: -10 });

                g.fillStyle(0x09121c, 1);
                g.fillEllipse(centerX, centerY, outerRadiusX * 2 + 300, outerRadiusY * 2 + 300);

                g.fillStyle(0x1e1e1e, 1);
                g.fillEllipse(centerX, centerY, outerRadiusX * 2, outerRadiusY * 2);

                g.fillStyle(0x142211, 1);
                g.fillEllipse(centerX, centerY, innerRadiusX * 2, innerRadiusY * 2);

                g.lineStyle(10, 0xffffff, 0.55);
                g.strokeEllipse(centerX, centerY, outerRadiusX * 2 - 120, outerRadiusY * 2 - 120);

                g.lineStyle(6, 0xffd700, 0.55);
                g.strokeEllipse(centerX, centerY, innerRadiusX * 2 + 40, innerRadiusY * 2 + 40);

                const startLine = this.add.rectangle(centerX, centerY + this.trackConfig.midRadiusY - 60, 280, 8, 0xffffff)
                    .setDepth(-6)
                    .setAngle(0);
                startLine.setAlpha(0.85);

                this.createOvalBarrier(this.trackWalls, centerX, centerY, innerRadiusX + 40, innerRadiusY + 40, 96, 80, 90);
                this.createOvalBarrier(this.trackWalls, centerX, centerY, outerRadiusX + 120, outerRadiusY + 120, 96, 90, 110, true);
            }

            createOvalBarrier(group, centerX, centerY, radiusX, radiusY, segments, lengthScalar = 90, thickness = 70, outer = false) {
                const step = Math.PI * 2 / segments;
                for (let i = 0; i < segments; i++) {
                    const angle = i * step;
                    const x1 = centerX + Math.cos(angle) * radiusX;
                    const y1 = centerY + Math.sin(angle) * radiusY;
                    const x2 = centerX + Math.cos(angle + step) * radiusX;
                    const y2 = centerY + Math.sin(angle + step) * radiusY;
                    const segLength = Phaser.Math.Distance.Between(x1, y1, x2, y2) * 1.08 + lengthScalar;

                    const wall = group.create((x1 + x2) / 2, (y1 + y2) / 2, 'wallTexture');
                    wall.setOrigin(0.5, 0.5);
                    wall.setRotation(angle + Math.PI / 2);
                    wall.setDisplaySize(segLength, thickness);
                    wall.refreshBody();
                    wall.setVisible(false);
                    wall.body.checkCollision.none = false;
                    wall.body.immovable = true;

                    if (outer) {
                        wall.body.setOffset(0, 0);
                    }
                }
            }

            createCars() {
                const startPositions = this.trackConfig.startPositions || [{ x: this.worldWidth / 2, y: this.worldHeight / 2, angle: -Math.PI / 2 }];
                const playerSpawn = startPositions[0];

                this.playerCar = this.spawnCar({
                    carId: this.carId,
                    x: playerSpawn.x,
                    y: playerSpawn.y,
                    angle: playerSpawn.angle,
                    isAI: false
                });

                if (this.isRaceTrack) {
                    const raceCfg = this.trackConfig.race;
                    for (let i = 0; i < raceCfg.aiCount; i++) {
                        const spawnIndex = Math.min(i + 1, startPositions.length - 1);
                        const spawn = startPositions[spawnIndex] || playerSpawn;
                        const aiIds = Object.keys(CAR_TYPES).filter(id => id !== this.carId);
                        const aiCarId = aiIds[i % aiIds.length];
                        const aiCar = this.spawnCar({
                            carId: aiCarId,
                            x: spawn.x,
                            y: spawn.y,
                            angle: spawn.angle,
                            isAI: true,
                            name: `AI #${i + 1}`
                        });
                        this.aiCars.push(aiCar);
                    }
                    this.racers = [this.playerCar, ...this.aiCars];
                } else {
                    this.racers = [this.playerCar];
                }
            }

            spawnCar({ carId, x, y, angle = 0, isAI = false, name = null }) {
                const carData = CAR_TYPES[carId] || CAR_TYPES.drift;
                const textureKey = `car_${carData.id}`;
                const sprite = this.physics.add.image(x, y, textureKey);
                sprite.setOrigin(0.5, 0.5);
                sprite.setRotation(angle);
                sprite.setCollideWorldBounds(true);
                sprite.body.setAllowRotation(false);
                sprite.body.setBounce(0.05);
                sprite.body.setDrag(0, 0);
                sprite.setDepth(1);

                sprite.body.setSize(120, 46, true);
                sprite.body.setOffset((sprite.width - 120) / 2, (sprite.height - 46) / 2);

                const car = {
                    id: carId,
                    data: carData,
                    sprite,
                    speed: 0,
                    carSpeedMph: 0,
                    health: carData.health || 100,
                    maxHealth: carData.health || 100,
                    isAI,
                    name: name || carData.name,
                    lap: this.isRaceTrack ? 1 : 0,
                    prevWaypoint: this.isRaceTrack ? this.trackConfig.race.waypoints.length - 1 : null,
                    nextWaypoint: 0,
                    raceProgress: 0,
                    finished: false,
                    retired: false,
                    position: 1,
                    localVelocity: new Phaser.Math.Vector2(0, 0),
                    angularVelocity: 0,
                    currentSteer: 0,
                    lastBoundaryHit: 0
                };

                sprite.setData('carRef', car);
                this.cars.push(car);

                return car;
            }

            setupCamera() {
                const zoom = this.trackConfig.cameraZoom || 0.8;
                this.cameras.main.startFollow(this.playerCar.sprite, true, 0.12, 0.12);
                this.cameras.main.setZoom(zoom);
                this.cameras.main.setBounds(0, 0, this.worldWidth, this.worldHeight);
                this.cameras.main.setBackgroundColor(this.trackId === 'daytona' ? 0x08131d : 0x161616);
            }

            setupControls() {
                this.keys = this.input.keyboard.addKeys({
                    up: Phaser.Input.Keyboard.KeyCodes.W,
                    down: Phaser.Input.Keyboard.KeyCodes.S,
                    left: Phaser.Input.Keyboard.KeyCodes.A,
                    right: Phaser.Input.Keyboard.KeyCodes.D,
                    handbrake: Phaser.Input.Keyboard.KeyCodes.SPACE,
                    reset: Phaser.Input.Keyboard.KeyCodes.R,
                    weather: Phaser.Input.Keyboard.KeyCodes.T,
                    menu: Phaser.Input.Keyboard.KeyCodes.ESC
                });
                this.cursors = this.input.keyboard.createCursorKeys();
            }

            setupCollisions() {
                if (this.trackWalls) {
                    this.cars.forEach(car => {
                        this.physics.add.collider(car.sprite, this.trackWalls, this.handleCarWallCollision, null, this);
                    });
                }

                this.aiCars.forEach(aiCar => {
                    this.physics.add.collider(this.playerCar.sprite, aiCar.sprite, this.handleCarVsCarCollision, null, this);
                });

                for (let i = 0; i < this.aiCars.length; i++) {
                    for (let j = i + 1; j < this.aiCars.length; j++) {
                        this.physics.add.collider(this.aiCars[i].sprite, this.aiCars[j].sprite, this.handleCarVsCarCollision, null, this);
                    }
                }
            }

            createUIOverlays() {
                this.countdownText = this.add.text(640, 180, '', {
                    fontFamily: 'Arial Black',
                    fontSize: '96px',
                    fill: '#ffd700',
                    stroke: '#000',
                    strokeThickness: 8
                }).setOrigin(0.5).setScrollFactor(0).setDepth(1000).setVisible(false);

                this.raceMessageText = this.add.text(640, 260, '', {
                    fontFamily: 'Arial',
                    fontSize: '32px',
                    fill: '#ffffff',
                    stroke: '#000',
                    strokeThickness: 6
                }).setOrigin(0.5).setScrollFactor(0).setDepth(1000).setVisible(false);

                if (this.isRaceTrack) {
                    this.hud.healthContainer.classList.remove('hidden');
                    this.hud.lapContainer.classList.remove('hidden');
                    this.hud.positionContainer.classList.remove('hidden');
                } else {
                    this.hud.healthContainer.classList.add('hidden');
                    this.hud.lapContainer.classList.add('hidden');
                    this.hud.positionContainer.classList.add('hidden');
                }
            }

            startRaceCountdown() {
                this.raceState = 'countdown';
                this.disableInput = true;
                let count = 3;

                this.countdownText.setText(count.toString()).setVisible(true);

                this.time.addEvent({
                    delay: 1000,
                    repeat: 3,
                    callback: () => {
                        count--;
                        if (count > 0) {
                            this.countdownText.setText(count.toString());
                        } else if (count === 0) {
                            this.countdownText.setText('GO!');
                            this.raceState = 'running';
                            this.disableInput = false;
                            this.time.delayedCall(700, () => this.countdownText.setVisible(false));
                        }
                    }
                });
            }

            getPlayerControls() {
                const up = this.keys.up.isDown || this.cursors.up.isDown;
                const down = this.keys.down.isDown || this.cursors.down.isDown;
                const left = this.keys.left.isDown || this.cursors.left.isDown;
                const right = this.keys.right.isDown || this.cursors.right.isDown;
                const handbrake = this.keys.handbrake.isDown;

                const control = {
                    throttle: 0,
                    brake: 0,
                    steer: 0,
                    reverse: false,
                    handbrake
                };

                if (!this.playerCar.retired) {
                    if (up) control.throttle = 1;
                    if (down) {
                        if (Math.abs(this.playerCar.localVelocity?.x || 0) > mphToPixels(2.5)) {
                            control.brake = 1;
                        } else {
                            control.reverse = true;
                        }
                    }
                }

                if (left) control.steer -= 1;
                if (right) control.steer += 1;
                control.steer = Phaser.Math.Clamp(control.steer, -1, 1);

                return control;
            }

            getAIControl(car) {
                const raceCfg = this.trackConfig.race;
                const waypoints = raceCfg.waypoints;
                const waypoint = waypoints[car.nextWaypoint];
                const sprite = car.sprite;

                const targetAngle = Phaser.Math.Angle.Between(sprite.x, sprite.y, waypoint.x, waypoint.y);
                let angleDiff = Phaser.Math.Angle.Wrap(targetAngle - sprite.rotation);
                angleDiff = Phaser.Math.Clamp(angleDiff, -Math.PI, Math.PI);

                const steer = Phaser.Math.Clamp(angleDiff / (Math.PI / 2), -1, 1);

                const speedMph = car.carSpeedMph || 0;
                const targetTop = Math.min(car.data.topSpeedMph - 2, 78);
                let throttle = 1;

                const angleSeverity = Math.abs(angleDiff);
                if (angleSeverity > 0.6) throttle = 0.7;
                if (angleSeverity > 0.9) throttle = 0.45;
                if (angleSeverity > 1.2) throttle = 0.2;

                if (speedMph > targetTop + 3) throttle = Math.min(throttle, 0.3);
                if (speedMph > targetTop + 6) throttle = 0;

                let brake = 0;
                if (speedMph > targetTop + 7) brake = 0.45;
                if (speedMph > targetTop + 12) brake = 0.8;

                const playerProgress = this.playerCar.raceProgress || 0;
                if (!car.finished && !this.playerCar.finished) {
                    if (car.raceProgress < playerProgress - 0.12) {
                        throttle = Math.min(1.05, throttle + 0.3);
                    } else if (car.raceProgress > playerProgress + 0.18) {
                        throttle = Math.max(0.55, throttle - 0.35);
                    }
                }

                return {
                    throttle: Phaser.Math.Clamp(throttle, 0, 1.1),
                    brake,
                    steer,
                    reverse: false,
                    handbrake: false
                };
            }

            syncLocalVelocityFromBody(car) {
                const sprite = car.sprite;
                const bodyVel = sprite.body.velocity;
                const sin = Math.sin(sprite.rotation);
                const cos = Math.cos(sprite.rotation);
                const observedForward = cos * bodyVel.x + sin * bodyVel.y;
                const observedLateral = -sin * bodyVel.x + cos * bodyVel.y;

                car.localVelocity.x = Phaser.Math.Linear(car.localVelocity.x, observedForward, 0.18);
                car.localVelocity.y = Phaser.Math.Linear(car.localVelocity.y, observedLateral, 0.18);
            }

            applyCarPhysics(car, control, dt) {
                if (!car || car.retired) return;
                const data = car.data;
                const sprite = car.sprite;

                this.syncLocalVelocityFromBody(car);

                const maxSteer = Phaser.Math.DegToRad(data.maxSteerAngle || 32);
                const desiredSteer = control.steer * maxSteer;
                car.currentSteer = Phaser.Math.Angle.RotateTo(car.currentSteer || 0, desiredSteer, data.steerRate * dt);

                if (control.reverse) {
                    car.localVelocity.x = moveTowards(car.localVelocity.x, -data.maxReverseSpeed, data.engineForce * 0.55 * dt);
                } else {
                    car.localVelocity.x += data.engineForce * control.throttle * dt;
                }

                if (control.brake > 0) {
                    const brakeEffect = data.brakeForce * control.brake * dt;
                    car.localVelocity.x = moveTowards(car.localVelocity.x, 0, brakeEffect);
                }

                const longDrag = data.longitudinalDrag || 0.24;
                car.localVelocity.x -= car.localVelocity.x * longDrag * dt;

                const speedSign = car.localVelocity.x >= 0 ? 1 : -1;
                car.localVelocity.x -= speedSign * (data.rollingResistance || 6) * dt;

                if (control.handbrake) {
                    car.localVelocity.x = moveTowards(car.localVelocity.x, 0, data.handbrakeForce * dt * 0.8);
                }

                car.localVelocity.x = Phaser.Math.Clamp(car.localVelocity.x, -data.maxReverseSpeed, data.topSpeed);

                const vx = car.localVelocity.x;
                const vy = car.localVelocity.y;
                const omega = car.angularVelocity || 0;

                const gripScale = this.surfaceGrip;
                const cf = data.cornerStiffnessFront * gripScale;
                let cr = data.cornerStiffnessRear * gripScale;

                if (control.handbrake) {
                    cr *= 0.25;
                    car.localVelocity.y += Phaser.Math.Clamp(vx, -data.handbrakeForce, data.handbrakeForce) * 0.02;
                }

                const speed = Math.max(4, Math.abs(vx));
                const alphaFront = Math.atan2(vy + omega * data.cgToFront, speed) - (car.currentSteer || 0);
                const alphaRear = Math.atan2(vy - omega * data.cgToRear, speed);

                let frontForce = -cf * alphaFront;
                let rearForce = -cr * alphaRear;

                const maxLat = data.maxLateralForce;
                frontForce = Phaser.Math.Clamp(frontForce, -maxLat, maxLat);
                rearForce = Phaser.Math.Clamp(rearForce, -maxLat, maxLat);

                const totalLateral = frontForce + rearForce;

                car.localVelocity.y += (totalLateral / data.mass) * dt;
                car.localVelocity.y -= car.localVelocity.y * data.lateralDamping * dt;

                const yawTorque = data.cgToFront * frontForce - data.cgToRear * rearForce;
                car.angularVelocity = (car.angularVelocity || 0) + (yawTorque / data.inertia) * dt;
                car.angularVelocity *= 1 - Phaser.Math.Clamp(data.angularDamping * dt, 0, 0.92);

                if (Math.abs(car.localVelocity.x) < 1) car.localVelocity.x = 0;
                if (Math.abs(car.localVelocity.y) < 0.6) car.localVelocity.y = 0;
                if (Math.abs(car.angularVelocity) < 0.004) car.angularVelocity = 0;

                sprite.rotation += car.angularVelocity * dt;

                const sin = Math.sin(sprite.rotation);
                const cos = Math.cos(sprite.rotation);

                const worldVx = cos * car.localVelocity.x - sin * car.localVelocity.y;
                const worldVy = sin * car.localVelocity.x + cos * car.localVelocity.y;

                sprite.body.setVelocity(worldVx, worldVy);
                sprite.body.setAngularVelocity(0);

                car.speed = Math.sqrt(worldVx * worldVx + worldVy * worldVy);
                car.carSpeedMph = Math.round(car.speed / PIXELS_PER_MPH);
            }

            constrainCarToTrack(car) {
                if (!car || this.trackId !== 'daytona') return;
                const cfg = this.trackConfig;
                const sprite = car.sprite;
                const dx = sprite.x - cfg.centerX;
                const dy = sprite.y - cfg.centerY;

                const innerA = cfg.innerRadiusX + 60;
                const innerB = cfg.innerRadiusY + 60;
                const innerValue = (dx * dx) / (innerA * innerA) + (dy * dy) / (innerB * innerB);

                if (innerValue < 1) {
                    const factor = 1 / Math.sqrt(innerValue);
                    const targetX = cfg.centerX + dx * factor * 1.015;
                    const targetY = cfg.centerY + dy * factor * 1.015;

                    sprite.setPosition(targetX, targetY);
                    sprite.body.position.set(targetX - sprite.body.halfWidth, targetY - sprite.body.halfHeight);
                    sprite.body.velocity.set(sprite.body.velocity.x * 0.6, sprite.body.velocity.y * -0.1);

                    car.localVelocity.x *= 0.6;
                    car.localVelocity.y *= -0.4;
                    car.angularVelocity *= 0.25;

                    this.registerBoundaryHit(car, 'inner');
                }

                const outerA = cfg.outerRadiusX - 90;
                const outerB = cfg.outerRadiusY - 90;
                const outerValue = (dx * dx) / (outerA * outerA) + (dy * dy) / (outerB * outerB);

                if (outerValue > 1) {
                    const factor = 1 / Math.sqrt(outerValue);
                    const targetX = cfg.centerX + dx * factor * 0.985;
                    const targetY = cfg.centerY + dy * factor * 0.985;

                    sprite.setPosition(targetX, targetY);
                    sprite.body.position.set(targetX - sprite.body.halfWidth, targetY - sprite.body.halfHeight);
                    sprite.body.velocity.set(sprite.body.velocity.x * -0.2, sprite.body.velocity.y * 0.4);

                    car.localVelocity.x *= -0.3;
                    car.localVelocity.y *= 0.25;
                    car.angularVelocity *= 0.35;

                    this.registerBoundaryHit(car, 'outer');
                }
            }

            registerBoundaryHit(car, type) {
                if (!this.isRaceTrack) return;
                const now = this.time.now;
                if (now - car.lastBoundaryHit > 500) {
                    const dmg = type === 'outer' ? 14 : 8;
                    this.applyDamage(car, dmg, 'wall');
                    car.lastBoundaryHit = now;
                    if (car === this.playerCar) {
                        this.showRaceMessage(type === 'outer' ? 'Outside wall! Easy on the throttle.' : 'Stay off the apron!', 1100);
                    }
                }
            }

            updateWaypointProgress(car) {
                if (!this.isRaceTrack || car.retired) return;

                const raceCfg = this.trackConfig.race;
                const waypoints = raceCfg.waypoints;
                const total = waypoints.length;

                if (car.finished) {
                    car.raceProgress = raceCfg.laps + this.finishOrder.indexOf(car) + 1;
                    return;
                }

                const waypoint = waypoints[car.nextWaypoint];
                const distance = Phaser.Math.Distance.Between(car.sprite.x, car.sprite.y, waypoint.x, waypoint.y);

                if (distance < raceCfg.waypointRadius) {
                    car.prevWaypoint = car.nextWaypoint;
                    car.nextWaypoint = (car.nextWaypoint + 1) % total;
                    if (car.nextWaypoint === 0) {
                        car.lap += 1;
                    }
                }

                const prevPoint = waypoints[car.prevWaypoint];
                const nextPoint = waypoints[car.nextWaypoint];
                const segmentLength = Phaser.Math.Distance.Between(prevPoint.x, prevPoint.y, nextPoint.x, nextPoint.y) || 1;
                const distToNext = Phaser.Math.Distance.Between(car.sprite.x, car.sprite.y, nextPoint.x, nextPoint.y);
                const alongSegment = 1 - Phaser.Math.Clamp(distToNext / segmentLength, 0, 1);

                const lapBase = (car.lap || 1) - 1;
                const segmentProgress = (car.prevWaypoint + alongSegment) / total;
                car.raceProgress = lapBase + segmentProgress;

                if (car.lap > raceCfg.laps && !car.finished) {
                    car.finished = true;
                    car.raceProgress = raceCfg.laps + (this.finishOrder.length + 1) / 10;
                    this.finishOrder.push(car);
                    if (car === this.playerCar) {
                        this.onPlayerFinished();
                    } else {
                        this.showRaceMessage(`${car.name} crossed the finish!`, 2000);
                    }
                }
            }

            updateRacePositions() {
                if (!this.isRaceTrack) return;
                const racers = [...this.racers];
                racers.sort((a, b) => (b.raceProgress || 0) - (a.raceProgress || 0));
                racers.forEach((car, index) => {
                    car.position = index + 1;
                });

                if (this.playerCar) {
                    const total = this.racers.length;
                    const pos = this.playerCar.position || total;
                    this.hud.position.textContent = `${pos} / ${total}`;

                    const laps = this.trackConfig.race.laps;
                    if (this.playerCar.finished) {
                        this.hud.lap.textContent = `Finished`;
                    } else {
                        const currentLap = Phaser.Math.Clamp(this.playerCar.lap, 1, laps);
                        this.hud.lap.textContent = `${currentLap} / ${laps}`;
                    }
                }
            }

            handleCarWallCollision(sprite) {
                const car = sprite.getData('carRef');
                if (!car) return;

                const impactSpeed = car.speed || sprite.body.speed;
                if (impactSpeed < 70) return;

                car.localVelocity.x *= 0.55;
                car.localVelocity.y *= -0.35;
                car.angularVelocity *= -0.32;

                if (this.isRaceTrack) {
                    const dmg = Phaser.Math.Clamp(Math.round((impactSpeed / (car.data.topSpeed || 1)) * 18), 6, 24);
                    this.applyDamage(car, dmg, 'wall');
                }
            }

            handleCarVsCarCollision(spriteA, spriteB) {
                const carA = spriteA.getData('carRef');
                const carB = spriteB.getData('carRef');
                if (!carA || !carB) return;

                const dvx = spriteA.body.velocity.x - spriteB.body.velocity.x;
                const dvy = spriteA.body.velocity.y - spriteB.body.velocity.y;
                const relativeSpeed = Math.sqrt(dvx * dvx + dvy * dvy);

                if (relativeSpeed < 40) return;

                carA.localVelocity.x *= 0.82;
                carB.localVelocity.x *= 0.82;
                carA.localVelocity.y += (Math.random() - 0.5) * 30;
                carB.localVelocity.y += (Math.random() - 0.5) * 30;

                if (this.isRaceTrack) {
                    const dmg = Phaser.Math.Clamp(Math.round((relativeSpeed / carA.data.topSpeed) * 20), 5, 26);
                    this.applyDamage(carA, dmg, 'collision');
                    this.applyDamage(carB, dmg, 'collision');
                }
            }

            applyDamage(car, amount, source = '') {
                if (!car || car.retired || !this.isRaceTrack) return;

                car.health = Math.max(0, car.health - amount);
                car.localVelocity.x *= 0.78;
                car.localVelocity.y *= 0.55;
                car.angularVelocity *= 0.45;

                if (car === this.playerCar) {
                    if (source === 'collision') {
                        this.showRaceMessage('Contact! Keep it clean.', 1200);
                    } else if (source === 'wall') {
                        this.showRaceMessage('Impact! Car health dropping.', 1200);
                    }
                }

                if (car.health <= 0 && !car.retired) {
                    car.retired = true;
                    car.localVelocity.set(0, 0);
                    car.angularVelocity = 0;
                    car.sprite.body.setVelocity(0, 0);
                    car.sprite.setTint(0x333333);
                    this.showRaceMessage(`${car.name} is out!`, 1800);

                    if (car === this.playerCar) {
                        this.raceState = 'finished';
                        this.disableInput = true;
                    }
                }
            }

            onPlayerFinished() {
                if (!this.isRaceTrack) return;
                if (this.raceState !== 'finished') {
                    this.raceState = 'finished';
                    this.disableInput = true;
                    const placement = this.playerCar.position || this.racers.length;
                    const suffix = placement === 1 ? 'st' : placement === 2 ? 'nd' : placement === 3 ? 'rd' : 'th';
                    this.showRaceMessage(`Race Complete! You finished ${placement}${suffix}.`, 4000);
                }
            }

            showRaceMessage(message, duration = 1800) {
                this.raceMessageText.setText(message);
                this.raceMessageText.setVisible(true);

                this.time.removeEvent(this.messageTimer);
                this.messageTimer = this.time.delayedCall(duration, () => {
                    this.raceMessageText.setVisible(false);
                });
            }

            resetPlayerCar() {
                const spawn = this.trackConfig.startPositions[0] || { x: this.worldWidth / 2, y: this.worldHeight / 2, angle: -Math.PI / 2 };
                const car = this.playerCar;

                car.sprite.setPosition(spawn.x, spawn.y);
                car.sprite.body.position.set(spawn.x - car.sprite.body.halfWidth, spawn.y - car.sprite.body.halfHeight);
                car.sprite.setRotation(spawn.angle);
                car.sprite.body.setVelocity(0, 0);

                car.localVelocity.set(0, 0);
                car.angularVelocity = 0;
                car.currentSteer = 0;
                car.speed = 0;
                car.carSpeedMph = 0;

                if (this.isRaceTrack) {
                    car.health = car.maxHealth;
                    car.lap = 1;
                    car.prevWaypoint = this.trackConfig.race.waypoints.length - 1;
                    car.nextWaypoint = 0;
                    car.raceProgress = 0;
                    car.finished = false;
                    car.retired = false;
                    car.sprite.clearTint();
                    car.sprite.body.enable = true;
                    this.finishOrder = [];
                    this.aiCars.forEach(ai => {
                        const idx = this.trackConfig.startPositions.indexOf(this.trackConfig.startPositions[1]);
                        const fallback = this.trackConfig.startPositions[idx >= 0 ? 1 : 0];
                        ai.sprite.setPosition(fallback.x, fallback.y);
                        ai.sprite.body.position.set(fallback.x - ai.sprite.body.halfWidth, fallback.y - ai.sprite.body.halfHeight);
                        ai.sprite.setRotation(fallback.angle);
                        ai.sprite.body.setVelocity(0, 0);
                        ai.localVelocity.set(0, 0);
                        ai.angularVelocity = 0;
                        ai.currentSteer = 0;
                        ai.health = ai.maxHealth;
                        ai.lap = 1;
                        ai.finished = false;
                        ai.retired = false;
                        ai.sprite.clearTint();
                    });
                    this.raceState = 'countdown';
                    this.startRaceCountdown();
                    this.showRaceMessage('Reset complete. Countdown restarting.', 1800);
                } else {
                    this.showRaceMessage('Back to center!', 1200);
                }
            }

            toggleWeather() {
                this.isRaining = !this.isRaining;
                if (this.trackConfig.allowRain) {
                    const weatherText = this.isRaining ? 'Rain üåßÔ∏è' : 'Clear ‚òÄÔ∏è';
                    this.hud.weather.textContent = weatherText;
                    this.surfaceGrip = this.isRaining ? 0.74 : 1.0;

                    if (this.isRaining) {
                        this.cameras.main.setBackgroundColor(0x1a2636);
                    } else {
                        this.cameras.main.setBackgroundColor(this.trackId === 'daytona' ? 0x08131d : 0x161616);
                    }
                }
            }

            update(time, delta) {
                if (!this.playerCar) return;

                const dt = delta / 1000;

                if (this.keys.menu.isDown) {
                    this.scene.start('MenuScene');
                    return;
                }

                if (Phaser.Input.Keyboard.JustDown(this.keys.weather) && this.trackConfig.allowRain) {
                    this.toggleWeather();
                }

                if (Phaser.Input.Keyboard.JustDown(this.keys.reset)) {
                    this.resetPlayerCar();
                }

                const playerControl = this.getPlayerControls();
                if (this.isRaceTrack && this.raceState !== 'running') {
                    playerControl.throttle = 0;
                    playerControl.reverse = false;
                    playerControl.brake = 1;
                    playerControl.handbrake = false;
                }

                this.applyCarPhysics(this.playerCar, playerControl, dt);
                this.constrainCarToTrack(this.playerCar);
                this.updateWaypointProgress(this.playerCar);

                this.aiCars.forEach(ai => {
                    const control = this.getAIControl(ai);
                    if (this.raceState !== 'running') {
                        control.throttle = 0;
                        control.brake = 1;
                    }
                    this.applyCarPhysics(ai, control, dt);
                    this.constrainCarToTrack(ai);
                    this.updateWaypointProgress(ai);
                });

                if (this.isRaceTrack) {
                    this.updateRacePositions();
                }

                this.updateHUD();
            }

            updateHUD(force = false) {
                if (!this.playerCar) return;

                this.hud.speed.textContent = this.playerCar.carSpeedMph;
                this.hud.carName.textContent = this.playerCar.data.name;
                this.hud.trackName.textContent = this.trackConfig.name;

                if (this.isRaceTrack || force) {
                    const healthRatio = Math.max(0, Math.round((this.playerCar.health / this.playerCar.maxHealth) * 100));
                    this.hud.health.textContent = this.playerCar.retired ? '0%' : `${healthRatio}%`;
                } else {
                    this.hud.health.textContent = '‚àû';
                }

                if (!this.isRaceTrack) {
                    this.hud.lap.textContent = '--';
                    this.hud.position.textContent = '--';
                }
            }
        }

        const config = {
            type: Phaser.AUTO,
            width: 1280,
            height: 720,
            parent: 'gameContainer',
            backgroundColor: '#2d2d2d',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: false
                }
            },
            scene: [MenuScene, GameScene]
        };

        new Phaser.Game(config);
    </script>
</body>
</html>